# Consumer Driven Contract - Consumer Side

This project illustrates using the Stubs generated by Spring Cloud Contract to validate the consumers interactions with the service.

In this project, the `stubs.jar` is used to create a mock of the `cdc-microservice`. This mock can be used in place of the real service whenever we need to do some isolated integration testing.

Because the mock service is based on the same contracts used to verify the server-side code, we can have a high degree of confidence that the interactions we're testing are realistic and reflect the behaviours of the real service.

 ## Setting up the project

 The first step is to setup the build script and bring in the Spring Cloud Contract dependencies. I’m not going to pring the whole build.gradle file here but the highlights are…

   1. In the dependencies, the Spring Cloud Contract `Stub Runner` is imported.

   ```groovy
   testCompile('org.springframework.cloud:spring-cloud-starter-contract-stub-runner')
   ```

   We'll use this 'Stub Runner' to create our Mock of the `cdc-microservice`.

## Setting up the Mock Server

Setting up your test to use the mock server is simply a case of adding the right annotations to the Spring Boot Test that you're working on. For example:-

```java
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"io.pivotalservices:cdc-microservice:+:stubs:6565"}, workOffline = true)
@DirtiesContext
public class LoanApplicationServiceTests {

    @Autowired
    private LoanApplicationService service;

    @Test
    public void shouldSuccessfullyApplyForLoan() {
        // given:
        LoanApplication application = new LoanApplication(new Client("1234567890"),
                123.123);
        // when:
        LoanApplicationResult loanApplication = service.loanApplication(application);
        // then:
        assertThat(loanApplication.getLoanApplicationStatus())
                .isEqualTo(LoanApplicationStatus.LOAN_APPLIED);
        assertEquals("Accepted", loanApplication.getResultText());
    }
}
```

This code is taken from the `LoanApplicationServiceTests` file in `src/test/java/io/pivotalservices`.

The main annotation of note here is `@AutoConfigureStubRunner` in which you are telling the Stub Runner where to find the contracts (in Maven under `io.pivotalservices:cdc-microservice`), which version of the archive to use (`+` means latest), the `stubs` archive jar, and finally to host the mock service on port `6565`.

## Interacting with the Mock Server

In this example, the code in our loan application app is programmed to interact with the service using a standard RestTemplate via the uri `http://localhost:6565/fraudcheck`, as you can see in the following code snippet:-

```java
private FraudServiceResponse sendRequestToFraudDetectionService(
    FraudServiceRequest request) {
  HttpHeaders httpHeaders = new HttpHeaders();
  httpHeaders.add(HttpHeaders.CONTENT_TYPE, FRAUD_SERVICE_JSON_VERSION_1);

  ResponseEntity<FraudServiceResponse> response =
      restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
          new HttpEntity<>(request, httpHeaders),
          FraudServiceResponse.class);

  return response.getBody();
}
```

When the test is run, the Stub Runner will obtain the contracts from the Maven repository and start a Mock service based on the instructions inside the `stubs.jar`. It uses WireMock to do this. This mock service will then wait for interactions on port 6565.

As the test executes, the mock is used in the place of the real service - meaning there is no longer a tightly-coupled runtime dependency between the consumer and the service. The consumer code is blissfully unaware of the fact that a mock service is being used.

## Summary

Because Spring Cloud Contract has introduced a mock upon which the developers of the consumers and the service can agree, there is greater confidence that the interactions between the two are correct and in sync.

By changing the code and the configuration (by using profiles for example) it would be possible to switch between testing using the mock service and testing using the real service. In many scenarios it is possible to leverage the reduced runtime dependency between the consumer and the service - inproving development cadence and increasing the autonomy of development teams.

This 'looser coupling' between components during development also offers greater flexibility when integration testing.
